# NumPy notes

these notes are mainly maken by reading *Python data science handbook*

## intro

NumPy（Numerical Python 的简称）提供了高效存储和操作密集数据缓存的接口。在某些方面，**NumPy 数组与 Python 内置的列表类型非常相似。但是随着数组在维度上变大，NumPy 数组提供了更加高效的存储和数据操作。**NumPy 数组几乎是整个 Python 数据科学工具生态系统的核心。因此，不管你对数据科学的哪个方面感兴趣，花点时间学习如何有效地使用 NumPy 都是非常值得的。

## 理解 Python 数据类型

Python 数据的数据类型和 C 的是不一样的，大致如下：

```C
struct _longobject {
    long ob_refcnt;
    PyTypeObject *ob_type;
    size_t ob_size;
    long ob_digit[1];
}
```

也就是说 Python 的整型中实际上包含了一些非必要的信息。所以相应的在处理数据的时候效率就会下降。

## Python 列表不仅仅是一个列表

因为 Python 的动态类型特性，可以创建一个异构的列表：

```Python
l = [1, 2, '3']
```

想拥有这种灵活性要付出一定代价：为了获得这些灵活的类型，列表中的每一项必须包含各自的类型信息、引用计数和其他信息；也就是说，每一项都是一个完整的 Python 对象。但如果列表中的所有变量都是同一类型的，那么很多信息都会显得多余——将数据存储在固定类型的数组中应该会更高效。动态类型的列表和固定类型的（NumPy 式）数组间的区别如图所示：

![](https://img-1259389933.cos.ap-guangzhou.myqcloud.com/20200911082531.png)

在实现层面，数组基本上包含一个指向连续数据块的指针。另一方面，Python 列表包含一个指向指针块的指针，这其中的每一个指针对应一个完整的Python 对象（如前面看到的 Python 整型）。另外，列表的优势是灵活，因为每个列表元素是一个包含数据和类型信息的完整结构体，而且列表可以用任意类型的数据填充。**固定类型的 NumPy 式数组缺乏这种灵活性，但是能更有效地存储和操作数据。**

## Python 中的固定类型数组

Python 提供了几种将数据存储在有效的、固定类型的数据缓存中的选项。内置的数组（array）模块（在Python 3.3 之后可用）可以用于创建统一类型的密集数组：

```Python
import array as arr

l1 = [i for i in range(3)]
a = arr.array('i', l1)
print(a)

# array('i', [0, 1, 2])
```

**这里的 'i' 是一个数据类型码，表示数据为整型。**

更实用的是 NumPy 包中的 ndarray 对象。**Python 的数组对象（在 Python 里面，数组指的是 array，list 是列表）提供了数组型数据的有效存储，而 NumPy 为该数据加上了高效的操作。**

## 创建 NumPy 数组的几种方法

[sample code](nparr_inialization.py)

从用 np 别名导入 NumPy 的标准做法开始：

```Python
import numpy as np
```

### 从 Python 列表创建数组

可以从 Python 列表创建 numpy 数组，同时可以使用 dtype 指定数组的数据类型：

```Python
i_nparr = np.array([1, 2, 3, 4, 5])
d_nparr = np.array([1.2, 3.2, 4], dtype='float32')
```

不同于 Python 列表，NumPy 数组可以被指定为多维的。

```Python
np.array([range(i, i + 3) for i in [2, 4, 6]])

# 事实上是 array([[2, 3, 4], [4, 5, 6], [6, 7, 8]])
```

内层的列表是二维数组的行。

### 从头创建数组

面对大型数组的时候，用 NumPy 内置的方法从头创建数组是一种更高效的方法。

```Python
# 创建一个长度为10的数组，数组的值都是0
np.zeros(10, dtype=int)
# array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])

# 创建一个 3×5 的浮点型数组，数组的值都是1
np.ones((3, 5), dtype=float)
# array([
# [1., 1., 1., 1., 1.],
# [1., 1., 1., 1., 1.],
# [1., 1., 1., 1., 1.]])

# 创建一个3×5的浮点型数组，数组的值都是3.14
np.full((3, 5), 3.14)
# array([
# [3.14, 3.14, 3.14, 3.14, 3.14],
# [3.14, 3.14, 3.14, 3.14, 3.14],
# [3.14, 3.14, 3.14, 3.14, 3.14]])

# 创建一个3×5的浮点型数组，数组的值是一个线性序列

# 从0开始，到20结束，步长为2
# （它和内置的range()函数类似）
np.arange(0, 20, 2)

# array([0, 2, 4, 6, 8, 10, 12, 14, 16, 18])
# 创建一个5个元素的数组，这5个数均匀地分配到0~1
np.linspace(0, 1, 5)
# array([0., 0.25, 0.5, 0.75, 1.])

# 创建一个3×3的、在0~1均匀分布的随机数组成的数组
np.random.random((3, 3))
# array([
# [0.99844933, 0.52183819, 0.22421193],
# [0.08007488, 0.45429293, 0.20941444],
# [0.14360941, 0.96910973, 0.946117]])

# 创建一个3×3的、均值为0、方差为1的
# 正态分布的随机数数组
np.random.normal(0, 1, (3, 3))
# array([
# [1.51772646, 0.39614948, -0.10634696],
# [0.25671348, 0.00732722, 0.37783601],
# [0.68446945, 0.15926039, -0.70744073]])

# 创建一个3×3的、[0, 10)区间的随机整型数组
np.random.randint(0, 10, (3, 3))
# array([
# [2, 3, 4],
# [5, 7, 8],
# [0, 5, 0]])

# 创建一个3×3的单位矩阵
np.eye(3)
# array([
# [1., 0., 0.],
# [0., 1., 0.],
# [0., 0., 1.]])

# 创建一个由3个整型数组成的未初始化的数组
# 数组的值是内存空间中的任意值
np.empty(3)
# array([1., 1., 1.])
```

### NumPy 标准数据类型

![](https://img-1259389933.cos.ap-guangzhou.myqcloud.com/20200911085553.png)

## NumPy 数组基础

Python 中的数据操作几乎等同于 NumPy 数组操作，甚至新出现的 Pandas 工具也是构建在 NumPy 数组的基础之上的。本节将展示一些用 NumPy 数组操作获取数据或子数组，对数组进行分裂、变形和连接的例子。

- 数组的属性：确定数组的大小、形状、存储大小、数据类型。
- 数组的索引：获取和设置数组各个元素的值。
- 数组的切分：在大的数组中获取或设置更小的子数组。
- 数组的变形：改变给定数组的形状。
- 数组的拼接和分裂：将多个数组合并为一个，以及将一个数组分裂成多个。

### NumPy 数组的属性

每个数组有 nidm（数组的维度）、shape（数组每个维度的大小）和 size（数组的元素个数）属性：

```Python
x = np.random.randint(10, size=6)

# x.ndim -> 1
# x.shape -> (6)
# x.size -> 6
```

另外一个有用的属性是 dtype，它是数组的数据类型。

### NumPy 数组的索引

一维 NumPy 数组和列表索引一样。

```Python
# x1 -> array([5, 0, 3, 3, 7, 9])
# x1[0] -> 5
# x1[4] -> 7
```

多维形式稍微有些不同，不同主要在于索引的第一个数值表示行，第二个表示列。

```Python
# x2 -> array([
# [3, 5, 2, 4],
# [7, 6, 8, 8],
# [1, 6, 7, 7]
# ])
# x2[0, 0] -> 3
# x2[2, 0] -> 1
# x2[2, -1] -> 7
```

### NumPy 数组的切分

一维 NumPy 数组和列表切片一样，`[start:end:step]`

多维数组示例如下：

```Python
# x2 -> array([
# [12, 5, 2, 4],
# [ 7, 6, 8, 8],
# [ 1, 6, 7, 7]])
# x2[:2, :3] # 两行，三列
# -> array([
# [12, 5, 2],
# [7, 6, 8]])
# x2[:3, ::2] # 所有行，每隔一列
```

#### 常用操作和注意事项

1. **获取数组的单行和单列**。

    你可以将索引与切片组合起来实现这个功能，用一个冒号（:）表示空切片：

    ```Python
    print(x2[:, 0]) # x2的第一列
    # [12 7 1]
    # print(x2[0, :]) # x2的第一行
    # [12 5 2 4]
    在获取行时，出于语法的简介考虑，可以省略空的切片：
    print(x2[0]) # 等于x2[0, :]
    # [12 5 2 4]
    ```

2. **非副本视图的子数组**。

  关于数组切片有一点很重要也非常有用，那就是**数组切片返回的是数组数据的视图，而不是数值数据的副本**。这一点也是 NumPy 数组切片和 Python 列表切片的不同之处：在 Python 列表中，切片是值的副本

3. **创建数组的副本。**

    尽管数组视图有一些非常好的特性，但是在有些时候明确地复制数组里的数据或子数组也是非常有用的。可以很简单地通过copy() 方法实现：

    ```Python
    x2_sub_copy = x2[:2, :2].copy()
    ```

### NumPy 数组的变形

另一个有用的操作类型是数组的变形。数组变形最灵活的实现方式是通过 reshape() 函数来实现。例如，如果你希望将数字 1~9 放入一个 3×3 的矩阵中，可以采用如下方法：

```Python
grid = np.arange(1, 10).reshape((3, 3))
print(grid)
# [
# [1 2 3]
# [4 5 6]                
# [7 8 9]
# ]
```
请注意，如果希望该方法可行，那么**原始数组的大小必须和变形后数组的大小一致**。如果满足这个条件，**reshape 方法将会用到原始数组的一个非副本视图**。

另外一个常见的变形模式是将一个一维数组转变为二维的行或列的矩阵。你也可以通过 reshape 方法来实现，或者更简单地在一个切片操作中利用 newaxis 关键字：

```Python
x = np.array([1, 2, 3])
# 通过变形获得的行向量
x.reshape((1, 3))
# array([[1, 2, 3]])

# 通过newaxis获得的行向量
x[np.newaxis, :]
# array([[1, 2, 3]])

# 通过变形获得的列向量
x.reshape((3, 1))
# array([
# [1],
# [2],
# [3]
# ])
# 通过newaxis获得的列向量
x[:, np.newaxis]
# array([
# [1],
# [2],
# [3]
# ])
```

### NumPy 数组的拼接和分裂

#### 数组的拼接

拼接或连接 NumPy 中的两个数组主要由 np.concatenate、np.vstack 和 np.hstack 实现。

```Python
x = np.array([1, 2, 3])
y = np.array([3, 2, 1])
x_and_y = np.concatenate([x, y])

# 多个也是可以的：np.concatenate([x, y, z])
```

np.concatenate 也可以用于二维数组的拼接：

```Python
grid = np.array([[1, 2, 3], [4, 5, 6]])
# 沿着第一个轴拼接，即沿着 x 轴进行拼接，扩展行
np.concatenate([grid, grid])
# array([
# [1, 2, 3],
# [4, 5, 6],
# [1, 2, 3],
# [4, 5, 6]
# ])
# 沿着第二个轴拼接（从0开始索引），即沿着 y 轴进行拼接，扩展列
np.concatenate([grid, grid], axis=1)
# array([
# [1, 2, 3, 1, 2, 3],
# [4, 5, 6, 4, 5, 6]
# ])
```

沿着固定维度处理数组时，使用 np.vstack（垂直栈）和 np.hstack（水平栈）函数会更简洁：

```Python
x = np.array([1, 2, 3])
grid = np.array([
    [9, 8, 7], 
    [6, 5, 4]])
# 垂直栈数组 vertical stack
np.vstack([x, grid])
# array([
# [1, 2, 3],
# [9, 8, 7],
# [6, 5, 4]])

# 水平栈数组 horizental stack
y = np.array([
    [99],
    [99]])
np.hstack([grid, y])
# array([
# [ 9, 8, 7, 99],
# [ 6, 5, 4, 99]])
```

与之类似，np.dstack 将沿着第三个维度拼接数组。

#### 数组的分裂

与拼接相反的过程是分裂。分裂可以通过 np.split、np.hsplit 和 np.vsplit 函数来实现。

可以向以上函数传递一个索引列表作为参数，索引列表记录的是分裂点位置：

```Python
x = [1, 2, 3, 99, 99, 3, 2, 1]
x1, x2, x3 = np.split(x, [3, 5])
print(x1, x2, x3)
# [1 2 3] [99 99] [3 2 1]
```

值得注意的是，N 分裂点会得到 N + 1 个子数组。相关的 np.hsplit 和 np.vsplit 的用法也类似：

```Python
grid = np.arange(16).reshape((4, 4))

# array([
# [ 0, 1, 2, 3],
# [ 4, 5, 6, 7],
# [ 8, 9, 10, 11],
# [12, 13, 14, 15]
# ])
upper, lower = np.vsplit(grid, [2])
print(upper)
print(lower)
# upper ->
# [
# [0 1 2 3]
# [4 5 6 7]
# ]
# lower ->
# [
# [ 8 9 10 11]
# [12 13 14 15]
# ]
left, right = np.hsplit(grid, [2])
print(left)
print(right)
# left ->
# [
# [ 0 1]
# [ 4 5]
# [ 8 9]
# [12 13]
# ]
# right ->
# [
# [ 2 3]
# [ 6 7]
# [10 11]
# [14 15]
# ]
```

## NumPy 数组的计算：通用函数

在接下来的几小节中，我们将深入了解 NumPy 在 Python 数据科学世界中如此重要的原因。明确点说，**NumPy 提供了一个简单灵活的接口来优化数据数组的计算**。

NumPy 数组的计算有时非常快，有时也非常慢。本节将介绍 NumPy 通用函数的重要性——**它可以提高数组元素的重复计算的效率**；然后，将会介绍很多 NumPy 包中常用且有用的数学通用函数。

### NumPy 的通用函数

通用函数有两种存在形式：一元通用函数（unary ufunc）对单个输入操作，二元通用函数（binary ufunc）对两个输入操作。

#### 数组的运算

NumPy 数组可以使用 Python 的运算符号进行运算，效果相当于对所有元素都进行相应的操作：+ - * / // **

所有这些算术运算符都是 NumPy 内置函数的简单封装器，例如 + 运算符就是一个 add 函数的封装器。

数学函数也可以用于 NumPy 数组，效果相当于对所有元素都进行相应的操作。

```Python
x = np.array([-2, -1, 0, 1, 2])

# 取绝对值
np.abs(x)

# 三角函数
np.sin(x)
np.arcsin(x)

# 指数
np.exp(x)
np.exp2(x)
np.power(3, x)
# return array([3^x1, 3^x2])

# 对数
np.log(x)
np.log2(x)
np.log10(x)
```

除此之外还有更多的运算，这里不多做介绍，去看文档吧。

#### 专用的通用函数

还有一个更加专用，也更加晦涩的通用函数优异来源是子模块 scipy.special。如果你希望对你的数据进行一些更晦涩的数学计算，scipy.special 可能包含了你需要的计算函数。这些函数能列一个长长的列表，下面的代码片段展示了一些可能在统计学中用到的函数：

```Python
from scipy import special
# Gamma函数（广义阶乘，generalized factorials）和相关函数
x = [1, 5, 10]
print("gamma(x) =", special.gamma(x))
print("ln|gamma(x)| =", special.gammaln(x))
print("beta(x, 2) =", special.beta(x, 2))
```

### 高级的通用函数特性

很多 NumPy 用户在没有完全了解通用函数的特性时就开始使用它们，这里将介绍一些通用函数的特殊性质。

#### 指定输出

在进行大量运算时，有时候指定一个用于存放运算结果的数组是非常有用的。不同于创建临时数组，你可以用这个特性将计算结果直接写入到你期望的存储位置。所有的通用函数都可以通过 out 参数来指定计算结果的存放位置：

```Python
x = np.arange(5)
y = np.empty(5)
np.multiply(x, 10, out=y)
print(y)
[0, 10, 20, 30, 40]
```

#### 聚合

二元通用函数有些非常有趣的聚合功能，这些聚合可以直接在对象上计算。例如，如果我们希望用一个特定的运算 reduce 一个数组，那么可以用任何通用函数的reduce 方法。一个 reduce 方法会对给定的元素和操作重复执行，直至得到单个的结果。
例如，对 add 通用函数调用 reduce 方法会返回数组中所有元素的和：

```Python
x = np.arange(1, 6)
np.add.reduce(x)
# 15
```

同样，对 multiply 通用函数调用 reduce 方法会返回数组中所有元素的乘积：

```Python
np.multiply.reduce(x)
# 120
```

如果需要存储每次计算的中间结果，可以使用accumulate：

```Python
np.add.accumulate(x)
# array([ 1, 3, 6, 10, 15])
np.multiply.accumulate(x)
# array([ 1, 2, 6, 24, 120])
```

在一些特殊情况中，NumPy 提供了专用的函数（np.sum、np.prod、np.cumsum、np.cumprod），它们也可以实现以上reduce 的功能，这些函数将在后面。

#### 外积

最后，任何通用函数都可以用 outer 方法获得两个不同输入数组所有元素对的函数运算结果。这意味着你可以用一行代码实现一个乘法表：

```Python
x = np.arange(1, 6)
np.multiply.outer(x, x)
# array([
# [ 1, 2, 3, 4, 5],
# [ 2, 4, 6, 8, 10],
# [ 3, 6, 9, 12, 15],
# [ 4, 8, 12, 16, 20],
# [ 5, 10, 15, 20, 25]
# ])
```

通用函数另外一个非常有用的特性是它能操作不同大小和形状的数组，一组这样的操作被称为广播（broadcasting）。这个主题非常重要，后面将介绍到。

### 通用函数的更多信息

NumPy 文档 和 SciPy 文档。

## 聚合

当你面对大量的数据时，第一个步骤通常都是计算相关数据的概括统计值。最常用的概括统计值可能是均值和标准差，这两个值能让你分别概括出数据集中的“经典”值，但是其他一些形式的聚合也是非常有用的（如求和、乘积、中位数、最小值和最大值、分位数，等等）。NumPy 有非常快速的内置聚合函数可用于数组。

### 数组值求和

先来看一个小例子，设想计算一个数组中所有元素的和。Python 本身可用内置的 sum 函数来实现：

```Python
import numpy as np
L = np.random.random(100)
sum(L)
# 55.61209116604941
```
它的语法和 NumPy 的 np.sum 函数非常相似，并且在这个简单的例子中的结果也是一样的。

但是，因为 NumPy 的 sum 函数在编译码中执行操作，所以 NumPy 的操作计算得更快一些：

```Python
big_array = np.random.rand(1000000)
%timeit sum(big_array)
%timeit np.sum(big_array)

# 10 loops, best of 3: 104 ms per loop
# 1000 loops, best of 3: 442 μs per loop
```

![](https://img-1259389933.cos.ap-guangzhou.myqcloud.com/20200911120736.png)

但是需要注意，sum 函数和 np.sum 函数并不等同，这有时会导致混淆。尤其是它们各自的可选参数都有不同的含义，np.sum 函数是知道数组的维度的，这一点将在接下来的部分讲解。

### 最小值和最大值

```Python
np.min(big_array)
np.max(big_array)
```

也可以使用 Python 的 min 和 max，但是更慢

#### 多维度聚合

聚合函数还有一个参数，用于指定沿着哪个轴的方向进行聚合。例如，可以通过指定 axis=0 找到每一列的最小值：

```Python
M.min(axis=0)
# array([ 0.66859307, 0.03783739, 0.19544769, 0.06682827])
```

这个函数返回四个值，对应四列数字的计算值。

同样，也可以找到每一行的最大值：

```Python
M.max(axis=1)
# array([ 0.8967576 , 0.99196818, 0.6687194])
```

其他语言的用户会对轴的指定方式比较困惑。axis 关键字指定的是数组将会被折叠的维度，而不是将要返回的维度。因此指定 axis=0 意味着第一个轴将要被折叠——对于二维数组，这意味着每一列的值都将被聚合。

#### 其他聚合函数

NumPy 提供了很多其他聚合函数，但是这里不会详细地介绍它们。另外，大多数的聚合都有对 NaN 值的安全处理策略（NaN-safe），即计算时忽略所有的缺失值，这些缺失值即特殊的 IEEE 浮点型 NaN 值（关于缺失值更全面的介绍请参见 3.5 节）。有些 NaN-safe 的函数直到 NumPy 1.8 版本才加进去，所以更早版本的 NumPy 并不支持此功能。

![](https://img-1259389933.cos.ap-guangzhou.myqcloud.com/20200911121616.png)

## 数组的计算：广播

NumPy 通过通用函数的向量化操作来减少缓慢的 Python 循环，另外一种向量化操作的方法是利用 NumPy 的广播功能。广播可以简单理解为用于不同大小数组的二进制通用函数（加、减、乘等）的一组规则。

```Python
import numpy as np
a = np.array([0, 1, 2])
b = np.array([5, 5, 5])
a + b
# array([5, 6, 7])
```

广播允许这些二进制操作可以用于不同大小的数组。例如，可以简单地将一个标量（可以认为是一个零维的数组）和一个数组相加：

```Python
a + 5
# array([5, 6, 7])
```

我们可以认为这个操作是将数值 5 扩展或重复至数组 [5, 5, 5]，然后执行加法。NumPy 广播功能的好处是，这种对值的重复实际上并没有发生，但是这是一种很好用的理解广播的模型。

我们同样也可以将这个原理扩展到更高维度的数组。观察以下将一个一维数组和一个二维数组相加的结果：

```Python
M = np.ones((3, 3))
# array([
# [ 1., 1., 1.],
# [ 1., 1., 1.],
# [ 1., 1., 1.]])

M + a
# array([
# [ 1., 2., 3.],
# [ 1., 2., 3.],
# [ 1., 2., 3.]])
```

这里这个一维数组就被扩展或者广播了。它沿着第二个维度扩展，扩展到匹配 M 数组的形状。

以上的这些例子理解起来都相对容易，更复杂的情况会涉及对两个数组的同时广播，例如以下示例：

```Python
a = np.arange(3)
# [0 1 2]
b = np.arange(3)[:, np.newaxis]
# [[0]
# [1]
# [2]]

a + b
# array([
# [0, 1, 2],
# [1, 2, 3],
# [2, 3, 4]])

# 这里 a 扩展为
# [0 1 2]
# [0 1 2]
# [0 1 2]
# 这是下面说的，沿着维度 1 扩展
# b 扩展为
# [0 0 0]
# [1 1 1] 
# [2 2 2] 
# 这也是沿着维度 1 扩展
```

正如此前将一个值扩展或广播以匹配另外一个数组的形状，这里将 a 和 b 都进行了扩展来匹配一个公共的形状，最终的结果是一个二维数组

### 广播的规则

NumPy 的广播遵循一组严格的规则，设定这组规则是为了决定两个数组间的操作。

- 规则1：如果两个数组的维度数不相同，那么小维度数组的形状将会在最左边补 1。这里不是补数字 1。

- 规则2：如果两个数组的形状在任何一个维度上都不匹配，那么数组的形状会沿着维度为 1 的维度扩展以匹配另外一个数组的形状。

- 规则3：如果两个数组的形状在任何一个维度上都不匹配并且没有任何一个维度等于1，那么会引发异常。

### 示例

#### 示例1

将一个二维数组与一个一维数组相加：

```Python
M = np.ones((2, 3))
a = np.arange(3)
```

来看这两个数组的加法操作。两个数组的形状如下：

```Python
M.shape = (2, 3)
a.shape = (3,)
```

可以看到，根据规则 1，数组 a 的维度数更小，所以在其左边补 1：

```Python
M.shape -> (2, 3)
a.shape -> (1, 3)
```

根据规则2，第一个维度不匹配，因此扩展这个维度以匹配数组：

```Python
M.shape -> (2, 3)
a.shape -> (2, 3)
```

现在两个数组的形状匹配了，可以看到它们的最终形状都为(2, 3)：

```Python
M + a
# array([
# [ 1., 2., 3.],
# [ 1., 2., 3.]])
```

不过事实上只要想象一个小的扩展成大的就行了


#### 示例2

来看两个数组均需要广播的示例：

```Python
a = np.arange(3).reshape((3, 1))
b = np.arange(3)
```

同样，首先写出两个数组的形状：

```Python
a.shape = (3, 1)
b.shape = (3,)
```

规则1告诉我们，需要用1将 b 的形状补全：

```Python
a.shape -> (3, 1)
b.shape -> (1, 3)
```

规则2告诉我们，需要更新这两个数组的维度来相互匹配：

```Python
a.shape -> (3, 3)
b.shape -> (3, 3)
```

因为结果匹配，所以这两个形状是兼容的，可以看到以下结果：

```Python
a + b
# array([
# [0, 1, 2],
# [1, 2, 3],
# [2, 3, 4]])
```

#### 广播示例3

现在来看一个两个数组不兼容的示例：

```Python
M = np.ones((3, 2))
a = np.arange(3)
```

两个数组的形状如下：

```Python
M.shape = (3, 2)
a.shape = (3,)
```

同样，规则1告诉我们，a 数组的形状必须用1进行补全：

```Python
M.shape -> (3, 2)
a.shape -> (1, 3)
```

根据规则2，a 数组的第一个维度进行扩展以匹配 M 的维度：

```Python
M.shape -> (3, 2)
a.shape -> (3, 3)
```

现在需要用到规则3——最终的形状还是不匹配，因此这两个数组是不兼容的。

### 广播操作的实际应用

可以实现数组的归一化和画一个二维函数等。

## 比较、掩码和布尔逻辑

这一节将会介绍如何用布尔掩码来查看和操作 NumPy 数组中的值。当你想基于某些准则来抽取、修改、计数或对一个数组中的值进行其他操作时，掩码就可以派上用场了。例如你可能希望统计数组中有多少值大于某一个给定值，或者删除所有超出某些门限值的异常点。在 NumPy 中，布尔掩码通常是完成这类任务的最高效方式。

### 和通用函数类似的比较操作

NumPy 数组可以使用比较操作符，效果和通用函数差不多，相当于广播然后比较。

```Python
x = np.arange(1, 6)
# x > 3
# array([False, False, False, False, True, True])
```

具体实现和加法一样，对应一些函数：

![](https://img-1259389933.cos.ap-guangzhou.myqcloud.com/20200912080127.png)

### 操作布尔数组

#### 统计记录的个数

使用下面的方法统计布尔数组中 True 记录的个数。

```Python
np.count_nonzero(x < 6)
```

类似的，可以使用 sum 函数统计 True 记录的 sum：

```Python
np.sum(x < 6)

# 可以沿某条轴操作
np.sum(x < 6, axis=1)
```

同时有两个有用的函数，any 和 all，分别对应存在和全部逻辑：

```Python
# 返回是否有 > 3 的元素
np.any(x > 3)
# True

# 返回是否全部大于 3
np.all(x > 3)
# False

# 可以沿某条轴操作
np.any(x < 6, axis=1)
```

#### 布尔运算符

布尔运算符 & | ^ ~ 可以用来实现完整的逻辑。

### 将布尔数组作为掩码

所谓掩码，就类似 filter，也就是筛选掉一些不满足条件的元素，或者反过来说是抽取一些满足条件的元素。

可以使用布尔数组作为索引进行掩码，这样为 True 的会留下来，False 的会无。

```Python
# 筛出 x < 5 的元素
x[x < 5]
```

注意，返回的 np 数组不是原来的 shape，会是一个一维数组，包含了所有满足条件的值。

人们经常困惑于关键字 and 和 or，以及逻辑操作运算符 & 和 | 的区别是什么，什么时候该选择哪一种？它们的区别是：and 和 or 判断整个对象是真或假，而 & 和 | 是指每个对象中的比特位。

当你在 NumPy 中有一个布尔数组时，该数组可以被当作是由比特字符组成的，其中 1 = True、0 = False。这样的数组可以用上面介绍的方式进行 & 和 | 的操作。而用 or 来计算这两个数组时，Python 会计算整个数组对象的真或假，这会导致程序出错。同样，对给定数组进行逻辑运算时，你也应该使用 | 或 &，而不是 or 或 and。如果试图计算整个数组的真或假，程序也同样会给出 ValueError 的错误：

因此可以记住：and 和 or 对整个对象执行单个布尔运算，而 & 和 | 对一个对象的内容（单个比特或字节）执行多个布尔运算。**对于 NumPy 布尔数组，后者是常用的操作。**

## “花哨” 的索引

在前面的小节中，我们看到了如何利用简单的索引值（如arr[0]）、切片（如arr[:5]）和布尔掩码（如arr[arr > 0]）获得并修改部分数组。在这一节中，我们将介绍另外一种数组索引，也称作**花哨的索引（fancy indexing）**。花哨的索引和前面那些简单的索引非常类似，**但是传递的是索引数组，而不是单个标量。**花哨的索引让我们能够快速获得并修改复杂的数组值的子数据集。

### 示例

花哨的索引在概念上非常简单，**它意味着传递一个索引数组来一次性获得多个数组元素。**例如以下数组：

```Python
[51 92 14 71 60 20 82 86 74 74]
```

假设我们希望获得三个不同的元素，可以用以下方式实现：

```Python
[x[3], x[7], x[2]]
[71, 86, 14]
```

另外一种方法是通过传递索引的单个列表或数组来获得同样的结果：

```Python
ind = [3, 7, 4]
x[ind]
array([71, 86, 60])
```

利用花哨的索引，结果的形状与索引数组的形状一致，而不是与被索引数组的形状一致：

```Python
ind = np.array([[3, 7],[4, 5]])
x[ind]
array([[71, 86],
[60, 20]])
```

花哨的索引也对多个维度适用。假设我们有以下数组：

```Python
array([
[ 0, 1, 2, 3],
[ 4, 5, 6, 7],
[ 8, 9, 10, 11]])
```

和标准的索引方式一样，第一个索引指的是行，第二个索引指的是列：

```Python
row = np.array([0, 1, 2])
col = np.array([2, 1, 3])
X[row, col]
array([ 2, 5, 11])
```

这里需要注意，结果的第一个值是X[0, 2]，第二个值是X[1, 1]，第三个值是X[2, 3]。在花哨的索引中，索引值的配对遵循2.5 节介绍过的广播的规则。因此当我们将一个列向量和一个行向量组合在一个索引中时，会得到一个二维的结果：

```Python
X[row[:, np.newaxis], col]
array([
[ 2, 1, 3],
[ 6, 5, 7],
[10, 9, 11]])
```

这里，每一行的值都与每一列的向量配对，正如我们看到的广播的算术运算：

```Python
row[:, np.newaxis] * col
array([
[0, 0, 0],
[2, 1, 3],
[4, 2, 6]])
```

这里特别需要记住的是，花哨的索引返回的值反映的是广播后的索引数组的形状，而不是被索引的数组的形状。

### 组合索引

花哨的索引可以和其他索引方案结合起来形成更强大的索引操作：

```Python
X:
[
[ 0 1 2 3]
[ 4 5 6 7]
[ 8 9 10 11]]
```

可以将花哨的索引和简单的索引组合使用：

```Python
X[2, [2, 0, 1]]
array([10, 8, 9])
```

也可以将花哨的索引和切片组合使用：

```Python
X[1:, [2, 0, 1]]
array([
[ 6, 4, 5],
[10, 8, 9]])
```

更可以将花哨的索引和掩码组合使用：

```Python
mask = np.array([1, 0, 1, 0], dtype=bool)
X[row[:, np.newaxis], mask]

array([
[ 0, 2],
[ 4, 6],
[ 8, 10]])
```

索引选项的组合可以实现非常灵活的获取和修改数组元素的操作。

## 数组的排序

### NumPy 中的快速排序

尽管 Python 有内置的 sort 和 sorted 函数可以对列表进行排序，但是这里不会介绍这两个函数，因为 NumPy 的 np.sort 函数实际上效率更高。**默认情况下，np.sort 的排序算法是快速排序**，其算法复杂度为[NlogN]，另外也可以选择归并排序和堆排序。对于大多数应用场景，默认的快速排序已经足够高效了。

如果想在不修改原始输入数组的基础上返回一个排好序的数组，可以使用 np.sort：
S
```Python
x = np.array([2, 1, 4, 3, 5])
np.sort(x)
array([1, 2, 3, 4, 5])
```

如果希望用排好序的数组替代原始数组，可以使用数组的sort 方法：

```Python
x.sort()
print(x)
[1 2 3 4 5]
```

另外一个相关的函数是argsort，该函数返回的是原始数组排好序的索引值：

```Python
x = np.array([2, 1, 4, 3, 5])
i = np.argsort(x)
print(i)
[1 0 3 2 4]
```

以上结果的第一个元素是数组中最小元素的索引值，第二个值给出的是次小元素的索引
值，以此类推。这些索引值可以被用于（通过花哨的索引）创建有序的数组：

```Python
x[i]
array([1, 2, 3, 4, 5])
```

#### 沿着行或列排序

NumPy 排序算法的一个有用的功能是通过 axis 参数，沿着多维数组的行或列进行排序，例如：

```Python
[[6 3 7 4 6 9]
[2 6 7 4 3 7]
[7 2 5 4 1 7]
[5 1 4 0 9 5]]

# 对X的每一列排序
np.sort(X, axis=0)
array([[2, 1, 4, 0, 1, 5],
[5, 2, 5, 4, 3, 7],
[6, 3, 7, 4, 6, 7],
[7, 6, 7, 4, 9, 9]])

# 对X的每一行排序
np.sort(X, axis=1)
array([[3, 4, 6, 6, 7, 9],
[2, 3, 4, 6, 7, 7],
[1, 2, 4, 5, 7, 7],
[0, 1, 4, 5, 5, 9]])
```

需要记住的是，这种处理方式是将行或列当作独立的数组，任何行或列的值之间的关系将会丢失！

### 部分排序：分隔

有时候我们不希望对整个数组进行排序，仅仅希望找到数组中第 K 小的值，NumPy 的 np.partition 函数提供了该功能。np.partition 函数的输入是数组和数字 K，输出结果是一个新数组，最左边是 K 个是前 K 小的值，往右是任意顺序的其他值：

```Python
x = np.array([7, 2, 3, 1, 6, 5, 4])
np.partition(x, 3)
array([2, 1, 3, 4, 6, 5, 7])
```

请注意，结果数组中前三个值是数组中最小的三个值，剩下的位置是原始数组剩下的值。在这两个分隔区间中，元素都是任意排列的。与排序类似，也可以沿着多维数组任意的轴进行分隔：

```Python
np.partition(X, 2, axis=1)
array([
[3, 4, 6, 7, 6, 9],
[2, 3, 4, 7, 6, 7],
[1, 2, 4, 5, 7, 7],
[0, 1, 4, 5, 9, 5]])
```

输出结果是一个数组，该数组每一行的前两个元素是该行最小的两个值，每行的其他值分布在剩下的位置。

最后，正如 np.argsort 函数计算的是排序的索引值，也有一个 np.argpartition 函数计算的是分隔的索引值

## 结构化数据：NumPy 的结构化数组


大多数时候，我们的数据可以通过一个异构类型值组成的数组表示，但有时却并非如此。本节介绍 NumPy 的结构化数组和记录数组，它们为复合的、异构的数据提供了非常有效的存储。尽管这里列举的模式对于简单的操作非常有用，但是**这些场景通常也可以用 Pandas 的 DataFrame 来实现。**